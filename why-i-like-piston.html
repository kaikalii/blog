<!DOCTYPE html><html><head><title>Kaikalii's Blog | Why I like Piston, a Rust game engine</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><meta name="robots" content="index,follow"><meta name="theme-color" content="#212121"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link rel="shortcut icon" href="/coding-blog-boilerplate/favicon.ico"><link href="https://fonts.googleapis.com/css?family=Hind:400,700&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:300,400&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/icon?family=Material+Icons%7CMaterial+Icons+Outlined&amp;display=swap" rel="stylesheet"><style>
      body, input, button {
        font-family: 'Hind', sans-serif;
      }

      code, .hljs {
        font-family: 'Source Code Pro', 'Courier New', Courier, monospace;
      }

      .icon-font {
        font-family: 'Material Icons';
        font-weight: normal;
        font-style: normal;
        font-size: 24px;  /* Preferred icon size */
        display: inline-block;
        line-height: 1;
        text-transform: none;
        letter-spacing: normal;
        word-wrap: normal;
        white-space: nowrap;
        direction: ltr;
      
        /* Support for all WebKit browsers. */
        -webkit-font-smoothing: antialiased;
        /* Support for Safari and Chrome. */
        text-rendering: optimizeLegibility;
      
        /* Support for Firefox. */
        -moz-osx-font-smoothing: grayscale;
      
        /* Support for IE. */
        font-feature-settings: 'liga';
      }

      .icon-font.outline {
        font-family: 'Material Icons Outlined';
      }
    </style><link href="/coding-blog-boilerplate/styles/codedoc-styles.css" rel="stylesheet"><script async="" defer="" src="/coding-blog-boilerplate/bundle/codedoc-bundle.js"></script><script>window.githubConfig={"repo":"blog","user":"kaikalii"}</script><style>.container{padding-top: 0 !important}</style><style>#-codedoc-toc { backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px) }</style><meta name="twitter:title" content="Kaikalii's Blog | Why I like Piston, a Rust game engine"><meta property="og:type" content="article"><meta property="og:title" content="Kaikalii's Blog | Why I like Piston, a Rust game engine"><meta property="og:image" content="https://raw.githubusercontent.com/bfops/playform/screenshots/screenshots/screenshot1.png"><meta name="keywords" content=""><meta property="blog-tags" content=""></head><body><div class="header-0-0-4"><a class="watermark-0-0-3" href="https://coding.blog" target="_blank"><svg viewBox="0 0 701 443" version="1.1" xmlns="http://www.w3.org/2000/svg"><g id="coding.blog" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g transform="translate(-162.000000, -246.000000)" id="Shape"><path d="M538.081948,246.348452 L538.52402,246.445719 L538.52402,246.445719 L538.85529,246.526578 L538.85529,246.526578 L600.956012,263.165455 C602.767076,263.660918 604.526214,264.465865 606.146589,265.591976 C611.80881,269.527048 614.090389,276.211909 612.345003,282.123825 L538.2641,559.728905 C537.816127,561.562539 536.989561,563.335054 535.765607,564.944016 C530.70443,571.597248 520.764856,572.934442 513.564947,567.930724 C507.902727,563.995652 505.621148,557.310791 507.366534,551.398875 L577.145082,289.91439 L546.233523,281.631663 L462.305576,595.917544 L468.439004,634.645619 L493.907962,603.194573 C499.468987,596.327279 509.54413,595.268339 516.411424,600.829364 C523.278717,606.390389 524.337658,616.465532 518.776633,623.332826 L470.948283,682.395919 C466.887248,687.410879 460.418878,689.3283 454.55045,687.832105 L454.212574,687.741996 C448.224449,686.200133 443.421088,681.240355 442.392221,674.744345 L430.503202,599.680031 C430.418831,599.147339 430.361793,598.616628 430.331048,598.089327 C429.783912,595.705405 429.838457,593.220092 430.535776,590.858154 L519.361965,258.223717 L519.447729,257.889555 L519.447729,257.889555 L519.532157,257.586199 L519.627058,257.23399 C520.074771,255.398716 520.901697,253.624577 522.126677,252.014264 C525.828762,247.147643 532.141006,245.125338 538.081948,246.348452 Z M632.156421,656.157784 C640.992977,656.157784 648.156421,663.321228 648.156421,672.157784 C648.156421,680.99434 640.992977,688.157784 632.156421,688.157784 L528.156421,688.157784 C519.319865,688.157784 512.156421,680.99434 512.156421,672.157784 C512.156421,663.321228 519.319865,656.157784 528.156421,656.157784 L632.156421,656.157784 Z M699.234631,342.452157 L857.62655,500.844076 C863.874939,507.092464 863.874939,517.223104 857.62655,523.471493 L699.234631,681.863412 C692.986243,688.1118 682.855603,688.1118 676.607214,681.863412 C670.358826,675.615023 670.358826,665.484383 676.607214,659.235995 L823.686132,512.157077 L676.607214,365.079574 C670.358826,358.831185 670.358826,348.700545 676.607214,342.452157 C682.855603,336.203768 692.986243,336.203768 699.234631,342.452157 Z M347.705627,342.452157 C353.954016,348.700545 353.954016,358.831185 347.705627,365.079574 L200.62671,512.158491 L347.705627,659.235995 C353.954016,665.484383 353.954016,675.615023 347.705627,681.863412 C341.457239,688.1118 331.326599,688.1118 325.07821,681.863412 L166.686292,523.471493 C160.437903,517.223104 160.437903,507.092464 166.686292,500.844076 L325.07821,342.452157 C331.326599,336.203768 341.457239,336.203768 347.705627,342.452157 Z"></path></g></g></svg></a></div><div id="-codedoc-container" class="container"><script>window.source = {"base":"posts","path":"why-i-like-piston.md","namespace":"/coding-blog-boilerplate","title":{"base":"Kaikalii's Blog","connector":" | "}}</script><div class="hero-0-0-13" data-mode="both" data-target="desktop" style="margin-bottom: -100px"><picture><source media="(min-width: 1025px)" srcset="https://raw.githubusercontent.com/bfops/playform/screenshots/screenshots/screenshot1.png"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" class="image-0-0-14" data-src="https://raw.githubusercontent.com/bfops/playform/screenshots/screenshots/screenshot1.png" data-hero=""></picture><span class="caption-0-0-15"></span></div><h1 class="h-0-0-10 white"><span style=" 
      text-shadow: 0 0 8px black; 
      font-size: 48px"><p>Why I like Piston, a Rust game engine</p></span></h1><script id="YSmcxixNPm">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("YSmcxixNPm", "tvU4ZvTyVzKC9UotaYeV1w==", {"src":"github"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><marker><br>

</marker><p>Rust is an increasingly popular programming language, and one of the things that people really like to program is games. As such, there are many available libraries for implementing game functionality. The APIs come in many flavors. I have tried many over the last couple years, but <a href="https://github.com/PistonDevelopers/piston">Piston</a>, which was one of the first I came across, remains my favorite.</p><h1 id="what-is-a-game-engine" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>What is a Game Engine?</h1><p>There are a few features of a library or framework that I would say define it as a game engine. In reality, no library fully implements a full game engine, nor could it. The engine of a game is specific to the game. Different games require different functionality, and each game has its own high-level abstractions that the developer generally builds. A game engine <em>library</em> is something upon which these abstractions are built.</p><p>In my opinion, for a library to be called a "game engine", it requires an API for doing at least two things:</p><h3 id="rendering-abstractions" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Rendering Abstractions</h3><p>Abstractions for rendering are critical to making a programmer's life easier when writing graphics code. Without it, they would be relegated to raw graphics API calls, which, if you have ever tried writing, say, OpenGL, is extremely cumbersome.</p><p>The most obvious features of a rendering abstraction include API for managing windows, textures, meshes, materials, and the whole graphics pipeline. A library gets bonus points for abstracting text rendering, cameras, scenes, or triangulation.</p><h3 id="input-abstractions" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Input Abstractions</h3><p>Most input abstractions are tied to the window being used, but not all. For most games, keyboard and mouse input, the two main types of ways we interact with computer games, are only collected when the window has focus. The are generally collected from an event loop, which may or may not be exposed to the library user. Touch-screen input, if available, can also be included here.</p><p>Other input devices, like gamepads or microphones, are usually handled more globally, and abstractions for them can often be relegated to libraries outside the engine.</p><h3 id="bonus-features" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Bonus Features</h3><p>Some game engines provide additional abstractions for other systems. The most common is an audio playback API. Others include game-specific abstractions for the filesystem, timers, and networking.</p><h1 id="the-rust-game-engine-landscape" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>The Rust Game Engine Landscape</h1><p>After only five years of stability, Rust has many game engine crates. A good list of them can be found in the <a href="https://github.com/rust-unofficial/awesome-rust#game-development">Awesome Rust repository</a>, and many more related crates can be found at <a href="https://arewegameyet.rs/">Are we game yet?</a>.</p><p>I'd like to talk briefly about the ones that I have tried or at least looked into.</p><h3 id="sfml" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>SFML</h3><p>The SFML crate provides Rust bindings for the <strong>S</strong>imple <strong>F</strong>ast <strong>M</strong>edia <strong>L</strong>ibrary. I came to Rust having developed primarily in C++ previously. As an freshman computer engineering major, SFML lived up to the "simple* in its name. I still think it is a decent library <em>if you are using C++</em>. The Rust bindings have about 95% parity with the original implementation, with only a few API differences.</p><p>The problem with this, is that an API that works well in C++ does not necessarily work well in Rust. The SFML crate is, unfortunately, a good example of this. The primary pain point is lifetime parameters on types that would not have them had the API been designed in Rust. In addition, the need to include SFML <em>.dll</em> files with your executable seems cumbersome when most crates build this kind of thing dynamically and never concern the user.</p><h3 id="ggez" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>ggez</h3><p>ggez was one of the first Rust game engines to emerge. A lot of people like it, but I have two major gripes with its API design.</p><p>The first is that handling events is done through implementing a trait. Types that implement this trait are passed to a <code>run</code> function which runs the event loop and calls the trait's <code>update</code> and <code>draw</code> methods as needed. This is perfectly fine <em>as long as your feature needs lie entirely within what the API provides</em>. However, once you want some finer lever of control over the way your game runs, you have no way to get it. This makes ggez okay for prototyping but poor for more complex designs.</p><p>My second grievance is the way the API does function calls. <code>Context</code>, one of the main types in the library, has only one public method. All operations on it are done with various separate functions. For example, if you want to change the fullscreen mode of the window, you do not call a method of <code>Context</code> or even of some inner window. Instead, you call <code>graphics::set_fullscreen(&amp;mut context, FullscreenType::Windowed)</code>. <em>Every</em> operation you want to do using the <code>Context</code>, from drawing to getting user input, is done via regular functions in various modules of the crate being called with the context as an argument. In my opinion, this C-style API design has no place in any language that has method syntax.</p><h3 id="amethyst-and-bevy" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Amethyst and Bevy</h3><p>Amethyst and Bevy are two Entity-Component-System-based game engines which are currently both in development. They are both reasonably designed, although Bevy is quite a bit simpler without sacrificing power. ECS-based engines can be very useful <em>if your use case is suited to them</em>. The ideal game to use an ECS to implement is one with lots of different pieces that can be easily decoupled, of which many have shared behavior. Amethyst and Bevy are both well-suited for this, but I have found that many of the kinds of games that I have tried to make cannot be easily made to fit this model.</p><h3 id="quicksilver" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>quicksilver</h3><p>quicksilver is a very cool idea. Write your game once, and it can be compiled into both a native executable as well as a WebAssembly module that works in the browser. It also has a manually-managed event loop, which I like. Honestly, I don't have much bad to say about it. The API is very straightforward, but I have not used it enough to know of any shortcomings if they exist.</p><p>The only thing I might say is that, depending on what you want to do with your game, the ability to run it in a web browser may be useless. If you want to make a free game just for people to have fun with, then being able to run it in the browser is very neat. However, if you want to sell your game, you probably have no need for this, as you will likely simply distribute the executable to people who pay for it either through your own website or though a service like Steam.</p><hr><p>There are several more, but those are the ones that I have used other than the topic of this post. This brings us to...</p><h1 id="piston" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Piston</h1><p><img src="img/piston.png" alt="alt text" title="Piston"></p><p>Piston had greater popularity closer to when it was first released, but in the last year, many people have taken more interest in the ECS-based engines. However, I still think that Piston is very well designed and has its place in the Rust gamedev landscape. So, what is so great about it?</p><h3 id="modularity" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Modularity</h3><p>Piston bills itself as "A modular game engine written in Rust". While the ECS-based engines have modularity in spades, Piston's modularity feels much more "rusty". Engine behavior is defined by a large number of traits, each of which defines some different aspect of mid-to-high-level game engine functionality. These traits make up a front-end that lets your define your game behavior. Arbitrary back-ends can then be used to actually run your game. The PistonDevelopers GitHub organization contains a number of backend implementations as well as many other utility libraries for various game operations.</p><p>My favorite trait is the <a href="https://docs.rs/piston2d-graphics/0.36.0/graphics/trait.Graphics.html"><code>Graphics</code> trait from <code>piston2d-graphics</code></a>. It defines an arbitrary render-target interface. 2D graphics code written in your Piston applications can be made to target arbitrary graphics backends. For example, I made the crate <a href="https://docs.rs/graphics_buffer/"><code>graphics_buffer</code></a>, which is a <code>Graphics</code> implementation with a in-memory buffer as a backend. This allows the user to use the same code to both draw your game and take screenshots.</p><p>The <code>Window</code> and <code>AdvancedWindow</code> traits define generic window functionality. <code>BuildFromWindowSettings</code> lets you build different kinds of windows with the same settings. The <code>CharacterCache</code> trait abstracts a cache of textures rendered from fonts at various sizes.</p><p>There are so many more contained in the various Piston modular crates. In my opinion, this straightforward trait-based design makes the most of Rust's powerful type system.</p><h3 id="flexibility" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Flexibility</h3><p>I think that a good game engine should make certain common patterns easy to express without preventing the user from digging down to the lower levels of the implementation to fine-tune things.</p><p><code>piston_window</code>, Piston's all-in-one backend implementation, allows full access to the underlying window abstraction as well the the rendering device, encoder, and a resource factory. If you really want to, you can make raw OpenGL calls to implement custom pipelines.</p><p>Because the event loop is managed by the user, you have complete control over the execution. This level of micro-management is not for everyone, but I like it. If you want to make your logic simple, you can simply throw game update logic into the event loop, and it will happen in sequence with rendering. Alternatively, you can separate your update loop into another thread so that any physics systems in your game are not tied to the framerate. Which one of these you pick depends on how your game works and how it responds to putting state behind locks on in channels.</p><h3 id="vector-graphics" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Vector Graphics</h3><p>This is a small thing for most people, but being able to very easily draw arbitrary 2D primitives is very important to me. I am not a very good artist, so rather than making textures and sprites, I like to draw polygons and animate them with math.</p><p>Most APIs require you to build some kind of struct describing the polygon and then use a draw method or function. ECS-based engines force this data to be persistent, which is annoying when you have to write systems to keep it updated.</p><p>I prefer to actually store only as much data as is necessary to derive the shape. For example, if I need to draw a circle, I do not store the position of all its vertices. Instead, I store the position of its center and its radius. This can be used to calculate the vertices on the fly. While it's slightly less efficient, the functional style makes the code easier to reason about.</p><p>For example, the <code>piston2d-graphics</code> function for drawing a polygon can be called this simply:</p><pre class=""><code class="rust -codedoc-code-snippet code-0-0-16" tabindex="0"><span class="wmbar-0-0-19"><span></span><span></span><span></span><span></span></span><div class="line-0-0-18  -codedoc-code-line" data-content="polygon(color, &amp;vertices, transform, graphics);" id="code1-l1"><span class="lineCounter-0-0-17 prim -codedoc-line-counter">1<span class="-codedoc-line-link"><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span></span><span class="token function">polygon</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertices<span class="token punctuation">,</span> transform<span class="token punctuation">,</span> graphics<span class="token punctuation">)</span><span class="token punctuation">;</span></div><br></code></pre><p>This model allows primitive data to be stored persistently only if you really want/need to.</p><h1 id="batteries-not-included" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Batteries Not Included</h1><p>Piston's biggest fault is its lack of certain nicer features. Many things need to be handled or implemented by the user. These include:</p><ul><li>A built-in geometric vector type. This need prompted me to make the <a href="https://docs.rs/vector2math/"><code>vector2math</code> crate</a>.</li><li>Complex text formatting. I made the <a href="https://docs.rs/fit_text"><code>fit_text</code> crate</a> to add some of this functionality.</li><li>Audio playback. There is a repo or two in the PistonDevelopers organization to handle this, but I just use <a href="https://docs.rs/rodio"><code>rodio</code></a>, which is an excellent audio crate.</li></ul><p>Whether these missing features matter to you depends on what you look for in a game engine. I don't mind writing a little extra code, so they don't bother me much.</p><h1 id="conclusion" class="heading-0-0-11"><span class="anchor-0-0-12" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Conclusion</h1><p>If what I've described sounds good to you, then consider trying Piston out. It's modular, it's flexible, and there is very little you can't do with it if you are willing to implement a few of your own solutions.</p><p>I'd like to thank <a href="https://github.com/bvssvni">Sven Nilsen (bvssvni)</a>, creator and primary contributor to Piston. While development has slowed a bit, he still readily accepts pull-request from other contributors.</p><p>To learn more, you should check out the <a href="https://www.piston.rs/">Piston website</a> or get started immediately with the <a href="https://docs.rs/piston_window"><code>piston_window</code> docs</a>.</p><div class="contentnav-0-0-9" data-no-search=""><a href="#what-is-a-game-engine" class="h1" data-content-highlight="what-is-a-game-engine">What is a Game Engine?</a><a href="#rendering-abstractions" class="h3" data-content-highlight="rendering-abstractions">Rendering Abstractions</a><a href="#input-abstractions" class="h3" data-content-highlight="input-abstractions">Input Abstractions</a><a href="#bonus-features" class="h3" data-content-highlight="bonus-features">Bonus Features</a><a href="#the-rust-game-engine-landscape" class="h1" data-content-highlight="the-rust-game-engine-landscape">The Rust Game Engine Landscape</a><a href="#sfml" class="h3" data-content-highlight="sfml">SFML</a><a href="#ggez" class="h3" data-content-highlight="ggez">ggez</a><a href="#amethyst-and-bevy" class="h3" data-content-highlight="amethyst-and-bevy">Amethyst and Bevy</a><a href="#quicksilver" class="h3" data-content-highlight="quicksilver">quicksilver</a><a href="#piston" class="h1" data-content-highlight="piston">Piston</a><a href="#modularity" class="h3" data-content-highlight="modularity">Modularity</a><a href="#flexibility" class="h3" data-content-highlight="flexibility">Flexibility</a><a href="#vector-graphics" class="h3" data-content-highlight="vector-graphics">Vector Graphics</a><a href="#batteries-not-included" class="h1" data-content-highlight="batteries-not-included">Batteries Not Included</a><a href="#conclusion" class="h1" data-content-highlight="conclusion">Conclusion</a></div></div><div id="-codedoc-toc" class="toc-0-0-6"><div class="content-0-0-7"><p><a href="/coding-blog-boilerplate/">Home</a>
<a href="/coding-blog-boilerplate/why-i-like-piston">Why I like Piston, a Rust game engine</a></p><p><br><br></p><p>To add links to your other posts,
simply modify contents of <code>posts/_toc.md</code></p></div></div><div class="footer-0-0-5"><div class="left"><script id="LdTzQFqAmO">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("LdTzQFqAmO", "k0lYj9deiYXngpZFqYY0vQ==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div><div class="main"><div class="inside"></div></div><div class="right"><script id="moxdHMRSOE">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("moxdHMRSOE", "QtGDrozMmpfzLYU0jY3n+w==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><script id="ZDAQqlN_ef">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("ZDAQqlN_ef", "Rs0VnrLCFSwfOm1o3R6OHg==", {"namespace":"/coding-blog-boilerplate"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></body></html>